#### **指针数组和<u>数组指针</u>**
指针数组`int *p1[5];`  数组指针`int (*p2)[5];`

1.先是p1被定义为有五个的数组，再带指针；一个数组，每个数组存放一个指针变量；
2.p2先被定义为一个指针，指向一个有五个元素的数组；一个指向数组的指针。

**int (*p2) [5] = &a ; //a为定义的数组，去除数组的地址给指针。 普通指针int *p=a,因为a已经是数组的地址了。**

```c
#include <stdio.h>
int main()
{
  int a[5]={1,2,3,4,5};
  int (*p)[5]=&a;//特别注意：数组指针是一个指针，指向数组的指针。
  for (int i = 0; i < 5; i++)
  {
      printf("%d\n",*(*p+i));
  }
 }
```

out：1 2 3 4 5

#### **特别注意：多维数组**

```c
int b[4][5]  ----b[0]b[1]b[2]b[3];array为地址值，array+1为下一行第一个元素地址，array[0][0]为第一个元素的内容；*（array+1）解引用，将取值运算符作用于一个地址之上，把一个地址的值取出来称为解引用，想当于array[1]（仍为地址值）,指向第二行第一个元素的地址；如下所示。
```


$$
*(array+i)==array[i];    *(*(array+i)+j)==array[i][j]; *(*(*(array+i)+j)+k)==array[i][j][k];
$$

#### **数组指针和二维数组**

```c
int array[][3]={{0,1,2},{3,4,5}};
int (*p)[3]=array;
#include <stdio.h>
int main()
{
    int array[][3]={{0,1,2},{3,4,5}};
    int (*p)[3]=array;
    printf("%d\n",**(p+1));
    printf("%d\n",**(array+1));
    return 0;
}
```

out:3 3

**注释**：使用int (*p)[3]的原因是使用p+1时，编译器知道跳了多少字节，若用**p计算机不知道，p+1编译器只会跳一个字节。

#### **void指针类型**

```c
void 指针可以指向任何类型的值， 支持不同类型指针之间的合法转换， 但做好注释和检查， 否则很容混淆指针的类型。
```

#### **NULL指针**

在指针初始化的时候不知道指向哪里的时候可以给他一个NULL，int *p2=NULL野指针，或悬空指针；（不可对指针不进行初始化，可能会得到一个随机数据，但程序正常运行，使用NULL没办法对一个空指针进行解引用，则会导致程序报错，必须有后续的操作。）

#### 指向指针的指针

```c
int num=520; int *p=&num; int **pp=&p; printf("%d",**pp);----------520
```

```c
对于指针，int *p；p=&num；简单说，p里放地址,*p就是把p里存放的num的地址值拿出来然后取num的值；
**pp=&p就是pp里存放p的地址，一层解引用取出pp中存放的p的地址，二层解引用取出p中存放的num的地址拿出num的值来；
&p=pp &num=p=*pp
```

